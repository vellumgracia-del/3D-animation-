<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zaxs Air Canvas Z11 (Smooth & Skeleton)</title>
    
    <!-- Import Google Fonts Sci-Fi -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">

    <!-- MediaPipe Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            color: #0ff;
            font-family: 'Share Tech Mono', monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        .container {
            position: relative;
            width: 1280px;
            height: 720px;
            max-width: 100%;
            border: 1px solid #00aaaa;
            box-shadow: 0 0 15px #00aaaa;
            background: #000;
            overflow: hidden;
        }

        /* 1. Video Input (Disembunyikan/Opacity rendah) */
        .input_video {
            position: absolute;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            opacity: 0.3; 
            object-fit: cover;
        }

        /* 2. Canvas UTAMA (Untuk Hasil Gambar) */
        .drawing_canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            z-index: 2;
        }

        /* 3. Canvas OVERLAY (Untuk Rangka Tangan/Skeleton) */
        .skeleton_canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            z-index: 3;
            pointer-events: none;
        }

        /* 4. UI HUD */
        .hud-overlay {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* Status Panel */
        .status-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 20, 20, 0.8);
            border-left: 4px solid #0ff;
            padding: 15px;
            backdrop-filter: blur(5px);
        }

        .mode-text {
            font-size: 24px;
            font-weight: bold;
            margin-top: 5px;
            text-transform: uppercase;
        }

        /* Loading */
        .loader {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: #000;
            z-index: 50;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #0ff;
        }

        .legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            text-align: right;
            background: rgba(0,0,0,0.6);
            padding: 10px;
            border-radius: 8px;
        }
        
        .color-dot {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-left: 8px;
        }
    </style>
</head>
<body>

    <div class="loader" id="loader">
        <h1 style="font-family: 'Orbitron'">SYSTEM BOOT...</h1>
        <p>Loading Neural Network Modules</p>
    </div>

    <div class="container">
        <!-- Layer 0: Video Webcam -->
        <video class="input_video"></video>
        
        <!-- Layer 1: Canvas untuk Menggambar (Tinta Permanen) -->
        <canvas class="drawing_canvas"></canvas>

        <!-- Layer 2: Canvas untuk Skeleton (Dihapus tiap frame) -->
        <canvas class="skeleton_canvas"></canvas>

        <!-- Layer 3: HUD UI -->
        <div class="hud-overlay">
            <div class="status-panel">
                <div style="font-size: 14px; opacity: 0.8;">ACTIVE TOOL</div>
                <div class="mode-text" id="mode-display" style="color: #444;">STANDBY</div>
                <div style="font-size: 12px; margin-top:5px;">FINGERS: <span id="finger-count">0</span></div>
            </div>

            <div class="legend">
                <div>1 Finger: <span style="color:#ff3333">BEAM (Red)</span></div>
                <div>2 Fingers: <span style="color:#33ff33">HUD (Green)</span></div>
                <div>3 Fingers: <span style="color:#33ffff">ARC (Cyan)</span></div>
                <div>5 Fingers: <span style="color:#ffffff">WIPE MEMORY</span></div>
            </div>
        </div>
    </div>

    <script>
        // --- KONFIGURASI ---
        const videoElement = document.getElementsByClassName('input_video')[0];
        const drawingCanvas = document.getElementsByClassName('drawing_canvas')[0];
        const drawingCtx = drawingCanvas.getContext('2d');
        const skeletonCanvas = document.getElementsByClassName('skeleton_canvas')[0];
        const skeletonCtx = skeletonCanvas.getContext('2d');
        const modeDisplay = document.getElementById('mode-display');
        const fingerCountSpan = document.getElementById('finger-count');
        const loader = document.getElementById('loader');

        // Variabel Logic
        let currentMode = "STANDBY";
        let brushColor = "#000";
        let brushSize = 6;
        
        // SMOOTHING VARIABLES (Untuk gerakan halus)
        // Kita simpan posisi 'sebelumnya' (px, py) dan posisi 'interpolasi' (lx, ly)
        let lx = 0, ly = 0; 
        const LERP_FACTOR = 0.2; // 0.1 = Sangat smooth tapi lambat, 0.9 = Cepat tapi kasar. 0.2-0.3 ideal.

        function resizeCanvas() {
            drawingCanvas.width = videoElement.videoWidth || 1280;
            drawingCanvas.height = videoElement.videoHeight || 720;
            skeletonCanvas.width = videoElement.videoWidth || 1280;
            skeletonCanvas.height = videoElement.videoHeight || 720;
        }

        // --- FUNGSI MENGHITUNG JARI ---
        function countFingers(landmarks) {
            const tips = [8, 12, 16, 20]; // Telunjuk sampai Kelingking
            const pips = [6, 10, 14, 18]; // Sendi tengah
            let count = 0;

            // Logika Jempol (Cek posisi X karena jempol bergerak menyamping)
            // Note: Karena mirroring, logikanya dibalik
            if (landmarks[4].x < landmarks[3].x) { 
                count++; 
            }

            // Logika 4 Jari Lain (Cek posisi Y, ujung lebih tinggi dari sendi)
            tips.forEach((tip, index) => {
                if (landmarks[tip].y < landmarks[pips[index]].y) {
                    count++;
                }
            });
            return count;
        }

        // --- MATH: INTERPOLASI LINEAR (SMOOTHING) ---
        function lerp(start, end, amt) {
            return (1 - amt) * start + amt * end;
        }

        // --- CORE PROCESS ---
        function onResults(results) {
            loader.style.display = 'none';

            // 1. Bersihkan Canvas Skeleton (Agar rangka tidak menumpuk)
            // JANGAN bersihkan drawingCanvas, nanti gambarnya hilang
            skeletonCtx.clearRect(0, 0, skeletonCanvas.width, skeletonCanvas.height);

            // Jika tangan terdeteksi
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // --- VISUALISASI RANGKA TANGAN (SKELETON) ---
                // Menggunakan fungsi bawaan MediaPipe drawing_utils
                drawConnectors(skeletonCtx, landmarks, HAND_CONNECTIONS, 
                    {color: '#00ffff', lineWidth: 2}); // Garis Cyan
                drawLandmarks(skeletonCtx, landmarks, 
                    {color: '#ffffff', lineWidth: 1, radius: 3}); // Titik Putih

                // --- LOGIKA MENGGAMBAR ---
                const fingers = countFingers(landmarks);
                fingerCountSpan.innerText = fingers;

                // Koordinat ujung telunjuk (target gambar)
                const indexTip = landmarks[8];
                const targetX = indexTip.x * drawingCanvas.width;
                const targetY = indexTip.y * drawingCanvas.height;

                // Apply Smoothing (Lerp)
                // Jika ini frame pertama (lx masih 0), langsung set ke target agar tidak ada garis dari pojok 0,0
                if (lx === 0 && ly === 0) {
                    lx = targetX;
                    ly = targetY;
                } else {
                    lx = lerp(lx, targetX, LERP_FACTOR);
                    ly = lerp(ly, targetY, LERP_FACTOR);
                }

                // Tentukan Mode
                let isDrawing = false;

                if (fingers === 1) {
                    currentMode = "REPULSOR (RED)";
                    brushColor = "#ff0000";
                    modeDisplay.style.color = brushColor;
                    modeDisplay.style.textShadow = "0 0 15px red";
                    isDrawing = true;
                } else if (fingers === 2) {
                    currentMode = "SYSTEM (GREEN)";
                    brushColor = "#00ff00";
                    modeDisplay.style.color = brushColor;
                    modeDisplay.style.textShadow = "0 0 15px lime";
                    isDrawing = true;
                } else if (fingers === 3) {
                    currentMode = "ARC (CYAN)";
                    brushColor = "#00ffff";
                    modeDisplay.style.color = brushColor;
                    modeDisplay.style.textShadow = "0 0 15px cyan";
                    isDrawing = true;
                } else if (fingers === 5) {
                    currentMode = "WIPE MEMORY";
                    modeDisplay.style.color = "#fff";
                    modeDisplay.style.textShadow = "0 0 15px white";
                    // Hapus drawingCanvas
                    drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                    isDrawing = false;
                } else {
                    currentMode = "HOVERING";
                    modeDisplay.style.color = "#555";
                    modeDisplay.style.textShadow = "none";
                    isDrawing = false;
                    // Reset lerp agar saat mulai menggambar lagi tidak ada garis nyasar
                    // (Opsional: membiarkan nyambung juga bisa jadi efek artistik)
                }

                modeDisplay.innerText = currentMode;

                // --- PROSES GAMBAR KE CANVAS ---
                if (isDrawing) {
                    drawingCtx.beginPath();
                    // Kita menggambar garis SANGAT PENDEK dari posisi last frame ke posisi sekarang
                    // Karena FPS tinggi, ini akan terlihat seperti garis nyambung
                    // Namun, kita perlu menyimpan 'prevX' yang benar.
                    
                    // Trik: Menggambar lingkaran2 kecil rapat (seperti brush) atau garis
                    // Untuk performa terbaik: Garis
                    
                    // Simpan variabel state global untuk posisi sebelumnya
                    // Agar smooth, kita gambar dari 'posisi lerp sebelumnya' ke 'posisi lerp sekarang'
                    // Namun di loop ini, kita tidak punya variabel 'previous frame lerp'.
                    // Jadi kita gunakan pendekatan path simple:
                    
                    drawingCtx.lineWidth = brushSize;
                    drawingCtx.lineCap = 'round';
                    drawingCtx.strokeStyle = brushColor;
                    drawingCtx.shadowBlur = 10;
                    drawingCtx.shadowColor = brushColor;

                    // Gambar titik di lokasi sekarang
                    drawingCtx.moveTo(previousLerpX, previousLerpY);
                    drawingCtx.lineTo(lx, ly);
                    drawingCtx.stroke();
                }

                // Highlight Ujung Jari di Skeleton Canvas (Visual Feedback)
                skeletonCtx.beginPath();
                skeletonCtx.arc(lx, ly, 10, 0, 2 * Math.PI);
                skeletonCtx.strokeStyle = isDrawing ? brushColor : 'white';
                skeletonCtx.lineWidth = 2;
                skeletonCtx.stroke();

                // Simpan posisi lerp saat ini untuk frame berikutnya
                previousLerpX = lx;
                previousLerpY = ly;

            } else {
                // Jika tangan hilang dari kamera, reset status
                modeDisplay.innerText = "NO INPUT";
                modeDisplay.style.color = "#333";
            }
        }

        let previousLerpX = 0;
        let previousLerpY = 0;

        // --- SETUP MEDIAPIPE ---
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1, // Fokus 1 tangan agar tidak bingung
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        hands.onResults(onResults);

        // --- SETUP CAMERA ---
        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 1280,
            height: 720
        });

        camera.start().then(() => console.log("JARVIS Vision Active"));
        
        window.addEventListener('resize', resizeCanvas);
        // Panggil resize sekali di awal
        setTimeout(resizeCanvas, 1000); 

    </script>
</body>
</html>
